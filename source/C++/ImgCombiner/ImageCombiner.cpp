/********************************************************************
*																	*
* Author: keith70													*
* Date modified: 2012.04.06											*
* Description: Combine images(generated by "ImageCutter") together	*
*																	*
********************************************************************/

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "func.h"

#ifndef MAX_PATH
#define MAX_PATH 255
#endif

char* GetDir(char* dir, char* path); //从文件路径获取所在目录
void InitArg(char* path, char* dir); //请求并读入参数
int CreateMultDir(const char* sPath); //创建多级目录
unsigned GetConfNumByStr(char* str);  //从配置文件中某一行字符串中获取数值
void GetConfPathByStr(char* path, char* str); //从配置文件中某一行字符串中获取路径
int FillBits(unsigned char*** bits, char* path, unsigned** size);   //读取小块文件并将填充数据到内存

int main(int argc, char *argv[])
{
	setvbuf(stdout, (char *)NULL, _IONBF, 0);  //禁用缓冲

	char cfgReadPath[MAX_PATH] = {'\0'};   //main参数1: 输入配置文件路径
	char imgSavePath[MAX_PATH] = {'\0'};   //main参数2: 输出图像文件路径
	FILE* saveFile;   //输出图像文件指针
	FILE* cfgFile;    //读入配置文件指针
	imgSize partSize;  //小块标准尺寸(不考虑冗余)
	imgSize entireSize; //整体尺寸
	unsigned partExc;   //冗余度(像素)
	unsigned partCount; //小块数目
	char** partsPath;   //存放小块路径
	unsigned char*** allBits; //存放小块数据(以行为单位)
	unsigned** allSize; //存放小块实际尺寸 

	switch(argc)
	{
	case 1: //直接运行
		InitArg(cfgReadPath, imgSavePath);
		break;
	case 2: //命令行调用,一个参数,保存路径默认为:输入目录\combine\out.dat
		strcpy(cfgReadPath, argv[1]); 
		GetDir(imgSavePath, cfgReadPath);
		strcat(imgSavePath, "combine/out.dat");
		break;
	case 3: //命令行调用,两个参数
		strcpy(cfgReadPath, argv[1]);
		strcpy(imgSavePath, argv[2]);
		break;
	default: //错误
		fprintf(stderr, "Arguments Error!");
		return 0;
	}

	//打开输入config文件
	char* index = strrchr(cfgReadPath, '.');
	if(strcmp(index, ".conf") != 0)
	{
		fprintf(stderr, "config file format not correct!");
		return 0;
	}
	cfgFile = fopen(cfgReadPath, "r");
	if(NULL == cfgFile)
	{
		fprintf(stderr, "Open config file failed!");
		return 0;
	}

	//打开/创建输出文件
	char tmp[MAX_PATH] = {'\0'};
	GetDir(tmp, imgSavePath); 
	if(0 == CreateMultDir(tmp))
	{
		fprintf(stderr, "Create save file directory failed!");
		return 0;
	}
	saveFile = fopen(imgSavePath, "wb+");
	if(NULL == saveFile)
	{
		fprintf(stderr, "Create save file failed!");
		return 0;
	}

	//读入配置文件
	char *one_line;
	one_line = (char*)malloc((MAX_PATH*2)*sizeof(char));

	//读取总体信息
	fgets(one_line, MAX_PATH*2, cfgFile); //第1行
	fgets(one_line, MAX_PATH*2, cfgFile); //第2行
	fgets(one_line, MAX_PATH*2, cfgFile); //第3行
	entireSize.width = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第4行
	entireSize.height = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第5行
	partSize.width = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第6行
	partSize.height = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第7行
	partExc = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第8行
	partCount = GetConfNumByStr(one_line);
	fgets(one_line, MAX_PATH*2, cfgFile); //第9行

	//读取各块数据
	partsPath = (char**)malloc(partCount * sizeof(char*));
	allBits = (unsigned char***)malloc(partCount * sizeof(unsigned char**));
	allSize = (unsigned**)malloc(partCount * sizeof(unsigned*));
	for(unsigned i=0; i < partCount; i++)
	{
		//输出进度
		//fflush(stdout);
		fprintf(stdout, "%d%%\n", (int)(i/(partCount-1.0)*50));

		partsPath[i] = (char*)malloc((MAX_PATH*2) * sizeof(char));
		fgets(one_line, MAX_PATH*2, cfgFile);
		GetConfPathByStr(partsPath[i], one_line);
		if(0 == FillBits(&allBits[i], partsPath[i], &allSize[i])) //读取小块文件并将数据填充到allBits
		{
			fprintf(stderr, "Read file \"%s\" failed!", partsPath[i]);
			return 0;
		}
	}

	//整合各块数据并保存
	fwrite("ImgA", sizeof(char), 4, saveFile);  
	fwrite(&entireSize, sizeof(imgSize), 1, saveFile);
	
	unsigned xNum = (entireSize.width + partSize.width/2) / partSize.width;  //横向小块数目
	unsigned yNum = (entireSize.height + partSize.height/2) / partSize.height; //纵向小块数目


	for(unsigned m=0; m < yNum; m++)
	{
		//输出进度
		//fflush(stdout);
		fprintf(stdout, "%d%%\n", (int)(m/(yNum-1.0)*50) + 50);

		for(unsigned n=0; n < allSize[m*xNum][1]; n++)
		{	
			for(unsigned k=0; k < xNum; k++)
			{		
				fwrite(allBits[m*xNum + k][n], allSize[m*xNum + k][0], 1, saveFile);
			}
		}
	}

	//完成
	//fflush(stdout);
	fprintf(stdout, "100%% Done!\n");

	fclose(cfgFile);
	fclose(saveFile);
	return 0;
}